# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mainwin.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import PyQt5.QtGui
import PyQt5.QtWidgets
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import pyqtgraph as pg
import pyqtgraph.exporters
import soundfile as sf
from PyQt5 import QtGui, QtWidgets
from pyqtgraph import PlotWidget
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.platypus import Image
from reportlab.platypus import SimpleDocTemplate
from reportlab.platypus import Table
from reportlab.platypus import TableStyle
import mainlayout
from spectrogram import Ui_OtherWindow
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas


# signal class
class Signal(PlotWidget):

    def __init__(self, file_path, data, sample_rate):
        self.waveform = PlotWidget()
        self.file_path = file_path
        self.data = data
        self.sample_rate = sample_rate
        self.fft = None
        self.frequencies = None
        self.magnitude_spectrum = None
        self.phase_spectrum = None
        self.modified_data = None
        # initial plot range
        self.x_range = [0, 2000]

    # pg configurations
    pg.setConfigOptions(background='w')
    # anti aliasing to improve the appearance of a small image that's being scaled up
    pg.setConfigOptions(antialias=True)

    # for plotting after reading signal
    def plot_signal(self, data):
        x = np.arange(0, len(data), 1)
        self.waveform.showGrid(x=True, y=True)
        self.waveform.enableAutoRange(x=False, y=True)
        p = self.waveform.plot(pen='b', width=0.1)
        p.setData(x, data)
        # self.waveform.setYRange(min(self.data)-1.5, max(self.data)+1.5, padding=0)
        self.waveform.setXRange(self.x_range[0], self.x_range[1], padding=0.005)

        # to send signal when clicked
        self.waveform.scene().sigMouseClicked.connect(lambda: ui.detect_click(self.file_path))
        # self.win.closeEvent = self.closeEvent

    # plotting modified signal
    def plot_inverse(self, data):
        self.waveform2 = self.win2.addPlot(row=1, col=1)
        x = np.arange(0, len(data), 1)
        self.waveform2.showGrid(x=True, y=True)
        self.waveform2.enableAutoRange(x=False, y=True)
        p = self.waveform2.plot(pen='b', width=0.1)
        p.setData(x, data)
        # self.waveform.setYRange(min(self.data)-1.5, max(self.data)+1.5, padding=0)
        self.waveform2.setXRange(self.x_range[0], self.x_range[1], padding=0.005)

        # to send signal when clicked
        self.waveform2.scene().sigMouseClicked.connect(lambda: ui.detect_click(self.file_path))
        self.win2.closeEvent = self.closeEvent

    def generate_band(self):
        b1 = []
        b2 = []
        b3 = []
        b4 = []
        b5 = []
        b6 = []
        b7 = []
        b8 = []
        b9 = []
        b10 = []
        freqs = np.sort(self.frequencies)
        for freq in freqs:
            if freqs[0] <= freq < (freqs[-1] / 10):
                b1.append(freq)
            if (freqs[-1] / 10) <= freq < (2 * (freqs[-1] / 10)):
                b2.append(freq)
            if (2 * (freqs[-1] / 10)) <= freq < (3 * (freqs[-1] / 10)):
                b3.append(freq)
            if (3 * (freqs[-1] / 10)) <= freq < (4 * (freqs[-1] / 10)):
                b4.append(freq)
            if (4 * (freqs[-1] / 10)) <= freq < (5 * (freqs[-1] / 10)):
                b5.append(freq)
            if (5 * (freqs[-1] / 10)) <= freq < (6 * (freqs[-1] / 10)):
                b6.append(freq)
            if (6 * (freqs[-1] / 10)) <= freq < (7 * (freqs[-1] / 10)):
                b7.append(freq)
            if (7 * (freqs[-1] / 10)) <= freq < (8 * (freqs[-1] / 10)):
                b8.append(freq)
            if (8 * (freqs[-1] / 10)) <= freq < (9 * (freqs[-1] / 10)):
                b9.append(freq)
            if (9 * (freqs[-1] / 10)) <= freq <= (freqs[-1]):
                b10.append(freq)
        # print(b10)

    def slider(self, band, level):
        new_band = [f * level for f in band]

    def plot_fft_magnitude(self):
        # plot magnitude spectrum
        # x-Axis
        frequency = self.frequencies
        plt.plot(frequency, self.magnitude_spectrum)
        plt.xlabel("frequency (HZ)")
        plt.show()

    def plot_fft_phase(self):
        # plot magnitude spectrum
        # x-Axis
        frequency = self.frequencies
        plt.plot(frequency, self.phase_spectrum)
        plt.xlabel("frequency (HZ)")
        plt.show()

    def inverse_fft(self):
        fft = np.multiply(self.magnitude_spectrum, np.exp(1j * self.phase_spectrum))
        self.modified_data = np.fft.irfft(fft)
        self.plot_inverse(self.modified_data)

    def closeEvent(self, event):
        ui.signal_closed(self.file_path)


class Pin():
    def __init__(self):
        self.title = ''
        self.SignalPath = []
        self.GramPath = []
        self.pinElementTable = None

    def getPins(self, path):
        name = path.split("/")[-1]
        self.title = name
        self.SignalPath = [name + ".png"]
        self.GramPath = [name + "s" + ".png"]

    def genPinTable(self):
        pinElemTable = None
        pinElemWidth = 500
        pinElemHeight = 1000

        # 1) Build Structure

        titleTable = Table([[self.title]]
                           , pinElemWidth)

        S_picture = Image(self.SignalPath[0])
        S_picture.drawWidth = 200
        S_picture.drawHeight = 100

        G_picture = Image(self.GramPath[0])
        G_picture.drawWidth = 200
        G_picture.drawHeight = 100

        picSignal = Table([
            [S_picture]
        ], 250, 125)
        picGram = Table([
            [G_picture]
        ], 250, 125)

        PicTable = Table([
            [picSignal, picGram]
        ], [250, 250])

        self.pinElemTable = Table([
            [titleTable],
            [PicTable]
        ], pinElemWidth)

        # 2) Add Style
        # List available fonts
        '''
        from reportlab.pdfgen import canvas
        for font in canvas.Canvas('abc').getAvailableFonts(): 
            print(font)
        '''
        titleTableStyle = TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTSIZE', (0, 0), (-1, -1), 14),
            ('FONTNAME', (0, 0), (-1, -1),
             'Helvetica-Oblique'
             ),

            ('TOPPADDING', (0, 0), (-1, -1), 0),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 0),
        ])
        titleTable.setStyle(titleTableStyle)

        picTableStyle = TableStyle([
            ('LEFTPADDING', (0, 0), (-1, -1), 15),

            ('TOPPADDING', (0, 0), (-1, -1), 0),
        ])
        picSignal.setStyle(picTableStyle)
        picGram.setStyle(picTableStyle)

        pinElemTableStyle = TableStyle([
            ('BOX', (0, 0), (-1, -1), 3, colors.pink),

            ('TOPPADDING', (0, 0), (-1, -1), 0),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 0),
        ])
        self.pinElemTable.setStyle(pinElemTableStyle)


class Window(QtWidgets.QMainWindow, mainlayout.Ui_MainWindow):
    signals_windows = {}  # store signals paths' and their object

    def __init__(self):
        super(Window, self).__init__()
        # Using functions in the inherited class
        self.setupUi(self)

        # set pg configuration
        pg.setConfigOptions(background='w')
        # anti aliasing to improve the appearance of a small image that's being scaled up
        pg.setConfigOptions(antialias=True)

        # set the title
        self.setWindowTitle("MainWindow")

        # variables declaration
        self.path = None
        self.original_data = None  # store original signal data
        self.sample_rate = None  # store sample rate from signal file
        self.fft = None
        self.frequencies = None
        self.magnitude_spectrum = None
        self.phase_spectrum = None
        self.modified_data = None

        # plots
        self.original_waveform = None
        self.modified_waveform = None

        # self.signal = None  # have the created signal object
        self.pins = {}  # have signal path and created pin object
        self.signals_fft = {}
        self.selected_signal = None
        self.played = 0  # playing flag
        self.pause = 0  # pause flag

        # Actions
        self.actionOpen_signal.triggered.connect(self.open_sig)
        self.actionImport_signal_from_CSV_decimal_comma.triggered.connect(self.open_csv)
        # self.actionImport_signal_from_CSV_decimal_dot.triggered.connect(self.open_scv)
        self.actionZoom_In.triggered.connect(lambda: self.zoom(1))
        self.actionZoom_out.triggered.connect(lambda: self.zoom(0))
        self.actionPlay_signal_no_sound.triggered.connect(lambda: self.play_signal(3))
        # self.actionPlay_signal_no_sound.triggered.connect(lambda: self.play_signal(self.modified_data, self.modified_waveform, 3))
        self.actionStop_playing.triggered.connect(self.pause_signal)
        self.action_Signal_beginning.triggered.connect(lambda: self.signal_beginning(1))
        self.actionLeft.triggered.connect(lambda: self.signal_beginning(0))  ##scroll to left
        self.actionRight.triggered.connect(lambda: self.signal_end(0))  ##scroll to Right
        self.actionSignal_End.triggered.connect(lambda: self.signal_end(1))
        self.actionPlay_as_fast_as_possible.triggered.connect(self.play_fast)
        self.Export_pdf.triggered.connect(self.E_pdf)
        self.actionSpectrogram.triggered.connect(self.open_window)
        self.actionTime_FFT.triggered.connect(self.inverse_fft)
        self.checkBox_1.stateChanged.connect(self.color_pallette)
        self.checkBox_2.stateChanged.connect(self.color_pallette)
        self.checkBox_3.stateChanged.connect(self.color_pallette)
        self.checkBox_4.stateChanged.connect(self.color_pallette)
        self.checkBox_5.stateChanged.connect(self.color_pallette)


        self.showMaximized()
        self.show()

    def open_window(self):
        color_cmap="plasma"
        self.spectro_draw(color_cmap)
        self.window = QtWidgets.QMainWindow()
        self.ui = Ui_OtherWindow()
        self.ui.setupUi(self.window)

        #self.window.show()

    # open for signals .wav , .edf

    def open_sig(self):
        print("open_sig")
        self.path = PyQt5.QtWidgets.QFileDialog.getOpenFileName(None, 'Open', None, "WAV (*.wav)")[0]
        if self.path:
            if len(self.signals_windows) == 0:
                self.signals_windows[self.path] = self
            else:
                self.signals_windows[self.path] = OtherWindows()
                self.signals_windows[self.path].config(self.path)

            # load .wav data
            self.original_data, self.sample_rate = sf.read(self.path)
            self.modified_data = self.original_data
            # create signal object and plot
            self.signals_windows[self.path].create_signal()

    # open for signals .csv
    def open_csv(self):
        if len(self.signals) < 3:
            print("open_csv")
            path = PyQt5.QtWidgets.QFileDialog.getOpenFileName(None, 'Open', None, "CSV (*.csv)")[0]
            # if path:
            #     df = pd.read_csv(path, usecols=[0, 1])
            #     data = np.array(df.iloc[:, 1])
            #     # create signa object and plot
            #     self.create_signal(path, data)

    # create Signal object and plot signal
    def create_signal(self):
        self.original_waveform = self.plot(self.original_data)
        self.modified_waveform = self.plot(self.modified_data)
        self.verticalLayout_6.addWidget(self.original_waveform)
        self.verticalLayout_7.addWidget(self.modified_waveform)
        self.open_window()
        self.frame.show()
        # self.play_signal(self.modified_data, self.modified_waveform, 3)  # to be changed to step

        # create fft for signal
        self.signal_fft()
        # print(self.fft)
        self.play_signal(3)  # to be changed to step

    # for plotting after reading signal
    def plot(self, data):
        data_plot = PlotWidget()
        x_range = [min(data), min(data) + 2000]
        x = np.arange(0, len(self.original_data), 1)
        data_plot.showGrid(x=True, y=True)
        data_plot.enableAutoRange(x=False, y=True)
        p = data_plot.plot(pen='b', width=0.1)
        p.setData(x, data)
        data_plot.getViewBox().setLimits(xMin=min(data))
        data_plot.setXRange(x_range[0], x_range[1], padding=0.005)
        return data_plot

    # fft for signal
    def signal_fft(self):
        self.fft = np.fft.rfft(self.original_data)
        self.magnitude_spectrum = np.abs(self.fft)  # for calculating magnitude spectrum
        self.phase_spectrum = np.angle(self.fft)
        self.frequencies = np.fft.rfftfreq(len(self.original_data), d=1 / self.sample_rate)

    def inverse_fft(self):
        fft = np.multiply(self.magnitude_spectrum, np.exp(1j * self.phase_spectrum))
        self.modified_data = np.fft.irfft(fft)
        self.create_signal()

    # Zoom
    def zoom(self, mode):
        center_x = (self.original_waveform.getAxis("bottom").range[0] +
                    self.original_waveform.getAxis("bottom").range[1]) / 2
        center_y = 0
        # zoom in
        if mode == 1:
            self.original_waveform.getViewBox().scaleBy(y=0.9, x=0.9, center=(center_x, center_y))
            self.modified_waveform.getViewBox().scaleBy(y=0.9, x=0.9, center=(center_x, center_y))
        # zoom out
        else:
            self.original_waveform.getViewBox().scaleBy(y=(1 / 0.9), x=(1 / 0.9), center=(center_x, center_y))
            self.modified_waveform.getViewBox().scaleBy(y=(1 / 0.9), x=(1 / 0.9), center=(center_x, center_y))

    # play function and play as fast as possible
    def play_signal(self, step):
        self.pause = 0
        self.played = 1
        sig_length = len(self.original_data)
        starting_x = self.original_waveform.getAxis("bottom").range
        x_end = starting_x[1]
        # check if signal reached the end
        if starting_x[1] < sig_length:
            i = 1
            # play signal
            while x_end < sig_length:
                # break if pause is pressed
                if self.pause == 1:
                    break
                self.original_waveform.setXRange(starting_x[0] + step * i,
                                                 starting_x[1] + step * i, padding=0.005)
                self.modified_waveform.setXRange(starting_x[0] + step * i,
                                                 starting_x[1] + step * i, padding=0.005)  #

                QtWidgets.QApplication.processEvents()
                # x_end= x_end + step
                x_end = self.original_waveform.getAxis("bottom").range[1]
                i += 1

    def play_fast(self):
        self.pause_signal()
        self.play_signal(40)

    # pause function
    def pause_signal(self):
        self.pause = 1
        self.played = 0

    # to signal beginning
    def signal_beginning(self, mode):
        self.pause_signal()
        # get original xrange
        x_range = [min(self.original_data), min(self.original_data) + 2000]
        if mode == 1:  # start of the signal
            self.original_waveform.setXRange(x_range[0], x_range[1], padding=0.005)
            self.modified_waveform.setXRange(x_range[0], x_range[1], padding=0.005)  #
        else:
            x_start = self.original_waveform.getAxis("bottom").range[0]
            x_end = self.original_waveform.getAxis("bottom").range[1]
            # print(x_start)
            # print(x_end)
            if (x_start - 10) < 0:
                self.signal_beginning(1)
            else:
                self.original_waveform.setXRange(x_start - 10, x_end - 20, padding=0.005)
                self.modified_waveform.setXRange(x_start - 10, x_end - 20, padding=0.005)  #

    # to signal end
    def signal_end(self, mode):
        self.pause_signal()
        # set xrange to be
        if mode == 1:
            x_end = len(self.original_data)
            self.original_waveform.setXRange(x_end - 2000, x_end, padding=0.005)
            self.modified_waveform.setXRange(x_end - 2000, x_end, padding=0.005)

        else:
            x_start = self.original_waveform.getAxis("bottom").range[0]
            x_end = self.original_waveform.getAxis("bottom").range[1]
            # print(x_start)
            # print(x_end)
            if (x_end + 10) > len(self.original_data):
                self.signal_end(1)
            else:
                self.original_waveform.setXRange(x_start + 20, x_end + 10, padding=0.005)
                self.modified_waveform.setXRange(x_start + 20, x_end + 10, padding=0.005)

    # delete closed signal
    def signal_closed(self, file_path):
        # print(len(self.signals))
        del self.signals[file_path]
        # print(len(self.signals))

        # save signal plots

    def save(self):
        for sig in self.signals:
            # signal im save
            plot_data = self.signals[sig].waveform
            QtGui.QApplication.processEvents()
            exporter = pg.exporters.ImageExporter(plot_data)
            exporter.parameters()['width'] = 500
            name = sig.split("/")[-1]
            exporter.export(name + ".png")
            fig = plt.figure()
            plt.subplot(212)
            data = self.signals[sig].data
            plt.specgram(data, Fs=1000)
            plt.xlabel('Time(sec)')
            plt.ylabel('Frequency(Hz)')
            fig.savefig(name + "s" + ".png")
            plt.close(fig)

    def E_pdf(self):
        self.save()
        for i in self.signals:
            self.pins[i] = Pin()
            self.pins[i].getPins(i)
        # print(self.pins)

        fileName = 'pdfTable.pdf'

        self.pdf = SimpleDocTemplate(fileName, pagesize=letter)

        # append table elements
        self.elems = []
        for pin in self.pins:
            self.pins[pin].genPinTable()  # generate element for each signal
            self.elems.append(self.pins[pin].pinElemTable)
        self.pdf.build(self.elems)
        print("Report is done")

    def spectro_draw(self,colorcmap):
        # clearing old figure
        self.figure.clear()
        plt.specgram(self.original_data, Fs=self.sample_rate,cmap=colorcmap)
        plt.xlabel('Time(sec)')
        plt.ylabel('Frequency(Hz)')
        self.canvas.draw()
    def color_pallette(self):
        colors=['Purples', 'Blues', 'Greens', 'Oranges','cool']
        if self.checkBox_1.isChecked():
            self.spectro_draw(colors[0])
        elif self.checkBox_2.isChecked():
            self.spectro_draw(colors[1])
        elif self.checkBox_3.isChecked():
            self.spectro_draw(colors[2])
        elif self.checkBox_4.isChecked():
            self.spectro_draw(colors[3])
        elif self.checkBox_5.isChecked():
            self.spectro_draw(colors[4])






    # # emit path of the last clicked on signal
    # def detect_click(self, file_path):
    #     self.selected_signal = file_path
    #     # self.signal.emit(file_path)
    #     # print(file_path)


class OtherWindows(Window):
    def __init__(self):
        super().__init__()
        # # set the title
        # title = "win"
        # self.setWindowTitle(title)

    def config(self, path):
        self.signals_windows[path] = self


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    ui = Window()
    # ui.showMaximized()
    # ui.show()
    sys.exit(app.exec_())
